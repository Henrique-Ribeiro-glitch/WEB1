/ *! jQuery v3.5.1 | (c) Fundação JS e outros contribuidores | jquery.org/license * /
! function (e, t) {"use strict"; "object" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) throw new Error ("jQuery requer uma janela com um documento"); return t (e)}: t (e)} ("undefined"! = typeof window? window: this, function ( C, e) {"usar estrito"; var t = [], r = Object.getPrototypeOf, s = t.slice, g = t.flat? Function (e) {return t.flat.call (e)}: function (e) {return t.concat.apply ([], e)}, u = t.push, i = t.indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call (Object), y = {}, m = function (e) {return "function" == typeof e && "number"! = typeof e.nodeType}, x = function (e) {return null! = e && e === e.window}, E = C.document, c = {type:! 0, src:! 0, nonce:! 0, noModule:! 0}; função b (e, t , n) {var r, i, o = (n = n || E) .createElement ("script");if (o.text = e, t) for (r in c) (i = t [r] || t.getAttribute && t.getAttribute (r)) && o.setAttribute (r, i); n.head.appendChild (o ) .parentNode.removeChild (o)} função w (e) {return null == e? e + "": "object" == typeof e || "function" == typeof e? n [o.call (e) ] || "objeto": tipo de e} var f = "3.5.1", S = função (e, t) {retornar novo S.fn.init (e, t)}; função p (e) {var t = !! e && "comprimento" em e && e.length, n = w (e); retornar! m (e) &&! x (e) && ("matriz" === n || 0 === t || " número "== typeof t && 0 <t && t-1 in e)} S.fn = S.prototype = {jquery: f, construtor: S, comprimento: 0, toArray: function () {return s.call (this)}, get: function (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = S .merge (this.constructor (), e); retornar t.prevObject = this, t}, cada:function (e) {return S.each (this, e)}, map: function (n) {return this.pushStack (S.map (this, function (e, t) {return n.call (e, t, e)}))}, slice: function () {return this.pushStack (s.apply (this, arguments))}, primeiro: function () {return this.eq (0)}, last: function () { return this.eq (-1)}, even: function () {return this.pushStack (S.grep (this, function (e, t) {return (t + 1)% 2}))}, odd: function () {return this.pushStack (S.grep (this, function (e, t) {return t% 2}))}, eq: function (e) {var t = this.length, n = + e + (e <0? T: 0); return this.pushStack (0 <= n && n <t? [This [n]]: [])}, end: function () {return this.prevObject || this.constructor ()} , push: u, sort: t.sort, splice: t.splice}, S.extend = S.fn.extend = function () {var e, t, n, r, i, o, a = argumentos [0 ] || {}, s = 1, u = argumentos.comprimento, l =! 1; for ("booleano" == tipo de a && (l = a, a = argumentos [s] || {}, s ++), " objeto "== typeof a || m (a) || (a = {}), s === u && (a = this,s -); s <u; s ++) if (null! = (e = argumentos [s])) para (t em e) r = e [t], "__ proto __"! == t && a! == r && ( l && r && (S.isPlainObject (r) || (i = Array.isArray (r)))? (n = a [t], o = i &&! Array.isArray (n)? []: i || S.isPlainObject (n)? n: {}, i =! 1, a [t] = S.extend (l, o, r)): void 0! == r && (a [t] = r)); retornar a} , S.extend ({expando: "jQuery" + (f + Math.random ()). Substituir (/ \ D / g, ""), isReady:! 0, erro: função (e) {lançar novo Erro ( e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! e || "[objeto Object]"! == o.call (e)) && (! (t = r (e)) || "função" == typeof (n = v.call (t, "construtor") && t.constructor) && a.call (n) === l)}, isEmptyObject: function ( e) {var t; for (t in e) return! 1; return! 0}, globalEval: function (e, t, n) {b (e, {nonce: t && t.nonce}, n)}, cada: função (e, t) {var n, r = 0; if (p (e)) {para (n = e.comprimento; r <n; r ++) if (! 1 === t.call (e [r], r, e [r])) break} else for (r in e) if (! 1 === t. call (e [r], r, e [r])) break; return e}, makeArray: function (e, t) {var n = t || []; return null! = e && (p (Object (e ))? S.merge (n, "string" == typeof e? [E]: e): u.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: i.call (t, e, n)}, mesclar: função (e, t) {para (var n = + t.length, r = 0, i = e.length; r < n; r ++) e [i ++] = t [r]; return e.length = i, e}, grep: function (e, t, n) {for (var r = [], i = 0, o = e .length, a =! n; i <o; i ++)! t (e [i], i)! == a && r.push (e [i]); return r}, map: function (e, t, n ) {var r, i, o = 0, a = []; if (p (e)) para (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); else for (o em e) nulo! = (i = t (e [o], o, n)) && a.push (i); return g (a)} , guid: 1, support: y}), "function" == typeof Symbol && (S.fn [Symbol.iterator] = t [Symbol.iterator]), S.each ("Número booleano String Função Matriz Data RegExp Objeto Símbolo de erro ".split (" "), função (e, t) {n [" [objeto "+ t +"] "] = t.toLowerCase ()}); var d = função (n) {var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E, v, s, c, y, S = "chiar" +1 * nova data, p = n.documento, k = 0, r = 0, m = ue (), x = ue (), A = ue (), N = ue (), D = função (e, t) {return e === t && (l =! 0), 0}, j = {}. hasOwnProperty, t = [], q = t.pop, L = t.push, H = t.push, O = t .slice, P = function (e, t) {for (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; return-1}, R = "verificado | selecionado | assíncrono | foco automático | reprodução automática | controles | adiar | desativado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo", M = "[\\ x20 \\ t \\ r \ \ n \\ f] ", I =" (?: \\\\ [\\ da-fA-F] {1,6} "+ M +"? | \\\\ [^ \\ r \\ n \\ f] | [\\ w-] | [^ \ 0 - \\ x7f]) + ", W =" \\ ["+ M +" * ("+ I +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?:'((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ " | ("+ I +")) |) "+ M +" * \\] ", F =" :( "+ I +") (?: \\ ((('((?: \\\\. | [ ^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\\]] | "+ W +") *) |. *) \\) |) ", B = novo RegExp (M +" + "," g "), $ = novo RegExp ("^" + M + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + M + "+ $", "g"), _ = nova RegExp ("^" + M + "*," + M + "*"), z = nova RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*") , U = novo RegExp (M + "|>"), X = novo RegExp (F), V = novo RegExp ("^" + I + "$"), G = {ID: novo RegExp ("^ # (" + I + ")"), CLASSE: novo RegExp ("^ \\. (" + I + ")"), TAG: novo RegExp ("^ (" + I + "| [*])"), ATTR: novo RegExp ( "^ "+ W), PSEUDO: nova RegExp (" ^ "+ F), CHILD: nova RegExp (" ^ :( apenas | primeiro | último | enésimo | enésimo último) - (filho | do tipo) (?: \\ ("+ M +" * (par | ímpar | (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: new RegExp (" ^ (?: "+ R +") $ "," i "), needsContext: nova RegExp ("^" + M + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ (" + M + "* ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / HTML $ / i, Q = / ^ (?: input | select | textarea | button) $ / i, J = / ^ h \ d $ / i, K = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\ \\ [\\ da-fA-F] {1,6} "+ M +"? | \\\\ ([^ \\ r \\ n \\ f]) "," g "), ne = função (e, t) {var n = "0x" + e.slice (1) -65536; retornar t || (n <0? String.fromCharCode (n + 65536): String.fromCharCode (n >> 10 | 55296,1023 & n | 56320))}, re = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f - \ uFFFF \ w -] / g, ou seja = função (e, t) {return t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1) .toString (16) + "": "\\" + e}, oe = function () {T ()}, ae = be (function (e) {return! 0 === e.disabled && "fieldset" === e.nodeName.toLowerCase ()}, {dir: "parentNode", next: "legend"}); tente {H.apply (t = O.call (p .childNodes), p.childNodes), t [p.childNodes.length] .nodeType} catch (e) {H = {apply: t.length? function (e, t) {L.apply (e, O.call (t))}: função (e, t) {var n = e.length, r = 0; enquanto (e [n ++] = t [r ++]); e.length = n-1}}} função se ( t, e, n, r) {var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e? e.nodeType: 9; if (n = n || [], "string"! = typeof t ||! t || 1! == p && 9! == p && 11! == p) return n; if (! r && (T (e), e = e || C,E)) {if (11! == p && (u = Z.exec (t))) if (i = u [1]) {if (9 === p) {if (! (A = e.getElementById (i))) retorna n; if (a.id === i) retorna n.push (a), n} else if (f && (a = f.getElementById (i)) && y (e, a) && a. id === i) return n.push (a), n} else {if (u [2]) return H.apply (n, e.getElementsByTagName (t)), n; if ((i = u [3 ]) && d.getElementsByClassName && e.getElementsByClassName) return H.apply (n, e.getElementsByClassName (i)), n} if (d.qsa &&! N [t + ""] && (! v ||! v.test (t) ) && (1! == p || "objeto"! == e.Nome do nó.toLowerCase ())) {if (c = t, f = e, 1 === p && (U.test (t) || z.test (t))) {(f = ee.test (t) && ye (e.parentNode) || e) === e && d.scope || ((s = e.getAttribute ("id"))? s = s.replace (re, ie): e.setAttribute ("id", s = S)), o = (l = h (t)). comprimento; enquanto (o -) l [o] = ( s? "#" + s: ": escopo") + "" + xe (l [o]); c = l.join (",")} tente {return H.apply (n, f.querySelectorAll (c)), n} catch (e) {N (t,! 0)} finalmente {s === S && e.removeAttribute (" id ")} }} return g (t.replace ($, "$ 1"), e, n, r)} função ue () {var r = []; função de retorno e (t, n) {return r.push (t + " ")> b.cacheLength && delete e [r.shift ()], e [t +" "] = n}} função le (e) {return e [S] =! 0, e} função ce (e) {var t = C.createElement ("fieldset"); try {return !! e (t)} catch (e) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} function fe ( e, t) {var n = e.split ("|"), r = n.length; enquanto (r -) b.attrHandle [n [r]] = t} função pe (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n == = t) return-1; return e? 1: -1} função de (t) {return function (e) {return "input" === e.nodeName.toLowerCase () && e.type === t}} function he (n) {return function (e) {var t = e.nodeName.toLowerCase (); return ("input" === t || "botão "=== t) && e.type === n}} function ge (t) {return function (e) {return" form "in e? e.parentNode &&! 1 === e.disabled?" label "em e? "rótulo" em e.parentNode? e.parentNode.disabled === t: e.disabled === t: e.isDisabled === t || e.isDisabled! ==! t && ae (e) == = t: e.disabled === t: "rótulo" em e && e.disabled === t}} função ve (a) {return le (function (o) {return o = + o, le (function (e, t) {var n, r = a ([], e.length, o), i = r.length; enquanto (i -) e [n = r [i]] && (e [n] =! ( t [n] = e [n]))})})} função ye (e) {return e && "undefined"! = typeof e.getElementsByTagName && e} for (e em d = se.support = {}, i = se .isXML = function (e) {var t = e.namespaceURI, n = (e.ownerDocument || e) .documentElement;return! Y.test (t || n && n.nodeName || "HTML")}, T = se.setDocument = function (e) {var t, n, r = e? e.ownerDocument || e: p; return r! = C && 9 === r.nodeType && r.documentElement && (a = (C = r) .documentElement, E =! i (C), p! = C && (n = C.defaultView) && n.top! == n && ( n.addEventListener? n.addEventListener ("unload", oe,! 1): n.attachEvent && n.attachEvent ("onunload", oe)), d.scope = ce (function (e) {return a.appendChild (e) .appendChild (C.createElement ("div")), "undefined"! = typeof e.querySelectorAll &&! e.querySelectorAll (": scope fieldset div"). length}), d.attributes = ce (function (e) { return e.className = "i",! e.getAttribute ("className")}), d.getElementsByTagName = ce (function (e) {return e.appendChild (C.createComment ("")) ,! e.getElementsByTagName ("*").length}), d.getElementsByClassName = K.test (C.getElementsByClassName), d.getById = ce (function (e) {return a.appendChild (e) .id = S,! C.getElementsByName ||! C.getElementsByName (S) .length}), d.getById? (B.filter.ID = função (e) {var t = e.replace (te, ne); função de retorno (e) {return e.getAttribute ("id" ) === t}}, b.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n = t.getElementById (e); retornar n? [n] : []}}) :( b.filter.ID = function (e) {var n = e.replace (te, ne); função de retorno (e) {var t = "undefined"! = typeof e.getAttributeNode && e. getAttributeNode ("id"); return t && t.value === n}}, b.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && E) {var n, r, i , o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e) , r = 0;while (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]} return []}}), b.find.TAG = d .getElementsByTagName? function (e, t) {return "undefined"! = typeof t.getElementsByTagName? t.getElementsByTagName (e): d.qsa? t.querySelectorAll (e): void 0}: function (e, t) { var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return o}, b.find.CLASS = d.getElementsByClassName && function (e, t) {if ("undefined"! = typeof t.getElementsByClassName && E) return t.getElementsByClassName (e)}, s = [ ], v = [], (d.qsa = K.test (C.querySelectorAll)) && (ce (function (e) {var t; a.appendChild (e) .innerHTML = "<a id = '" + S + "'> </a> <select id ='" + S + "- \ r \\ 'msallowcapture =' '> <opção selecionada =' '> </ option> </select> ", e.querySelectorAll (" [msallowcapture ^ = ''] "). length && v.push (" [* ^ $] = "+ M +" * (?: '' | \ "\" ) "), e.querySelectorAll (" [selecionado] "). length || v.push (" \\ ["+ M +" * (?: valor | "+ R +") "), e.querySelectorAll (" [ id ~ = "+ S +" -] "). length || v.push (" ~ = "), (t = C.createElement (" input ")). setAttribute (" name "," "), e. appendChild (t), e.querySelectorAll ("[name = '']"). length || v.push ("\\ [" + M + "* name" + M + "* =" + M + "* (?: '' | \ "\") "), e.querySelectorAll (": verificado "). comprimento || v.push (": verificado "), e.querySelectorAll (" a # "+ S +" + * "). comprimento || v.push (". #. + [+ ~]"), e.querySelectorAll ("\\\ f"), v.push ("[\\ r \\ n \\ f]")}), ce (função (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <selecionar desativado = 'disabled'> <option /> </select> "; var t = C.createElement (" input "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" nome "," D "), e.querySelectorAll (" [name = d] "). length && v.push (" name "+ M +" * [* ^ $ |! ~]? = "), 2! == e .querySelectorAll (": enabled"). length && v.push (": enabled", ": disabled"), a.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": disabled"). length && v.push (": enabled", ": disabled"), e.querySelectorAll ("* ,: x"), v.push (",. *:")})), (d.matchesSelector = K.test (c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce (function (e) {d.disconnectedMatch = c.call (e, "*"), c.call (e, "[s! = '']: x "), s.push ("! = ", F)}), v = v.length && new RegExp (v.join (" | ")), s = s.length && new RegExp (s.join (" | ") ), t = K.test (a.compareDocumentPosition), y = t || K.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r )))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) return! 0; return! 1}, D = t? function (e, t ) {if (e === t) return l =! 0,0; var n =! e.compareDocumentPosition-! t.compareDocumentPosition; return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! d.sortDetached && t.compareDocumentPosition (e) === n? e == C || e.ownerDocument == p && y (p, e)? - 1: t == C || t.ownerDocument == p && y (p, t)? 1: u? P (u, e) -P (u, t): 0: 4 & n? -1: 1)}: função (e, t) {if (e === t) return l =! 0, 0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; se (! I ||! O) retornar e == C? -1 : t == C? 1: i? -1: o? 1: u? P (u, e) -P (u, t): 0; se (i === o) retornar pe (e, t) ; n = e; while (n = n.parentNode) a.unshift (n); n = t; while (n = n.parentNode) s.unshift (n); while (a [r] === s [ r]) r ++; retornar r? pe (a [r], s [r]): a [r] == p? -1: s [r] == p? 1: 0}), C}, se .matches = function (e, t) {return se (e, null, null, t)}, se.matchesSelector = function (e, t) {if (T (e), d.matchesSelector && E &&! N [t + "" ] && (! s ||! s.test (t)) && (! v ||! v.test (t))) tente {var n = c.call (e, t); if (n || d .disconnectedMatch || e.document && 11! == e.document.nodeType) return n} catch (e) {N (t,! 0)} return 0 <se (t, C, null, [e]). length} , se.contém = função (e, t) {return (e.ownerDocument || e)! = C && T (e), y (e, t)}, se.attr = function (e, t) {(e.ownerDocument || e)! = C && T (e); var n = b.attrHandle [t.toLowerCase ()], r = n && j.call (b.attrHandle, t.toLowerCase ())? n (e, t,! E): void 0; return void 0! == r? r: d.attributes ||! E? e.getAttribute (t) :( r = e.getAttributeNode (t)) && r.specified? r.value: null}, se .escape = function (e) {return (e + ""). replace (re, ie)}, se.error = function (e) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + e)}, se .uniqueSort = function (e) {var t, n = [], r = 0, i = 0; if (l =! d.detectDuplicates, u =! d.sortStable && e.slice (0), e.sort (D ), l) {enquanto (t = e [i ++]) t === e [i] && (r = n.push (i)); enquanto (r -) e.splice (n [r], 1 )} return u = null, e}, o = se.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; if (i) {if (1 === i || 9 === i || 11 === i) {if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else if (3 === i || 4 === i) return e.nodeValue } else while (t = e [r ++]) n + = o (t); return n}, (b = se.selectors = {cacheLength: 50, createPseudo: le, match: G, attrHandle: {}, find: { }, relativo: {">": {dir: "parentNode", primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1] .replace (te, ne), e [3] = (e [3 ] || e [4] || e [5] || ""). substituir (te, ne), "~ =" === e [2] && (e [3] = "" + e [3 ] + ""), e.slice (0,4)}, CHILD: function (e) {return e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (E [3] || se.error (e [0]), e [4] = + (e [4]? E [5] + (e [6] || 1): 2 * ("par" === e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar "=== e [3])): e [3] && se.error (e [0]), e}, PSEUDO: função (e) {var t, n =! e [6] && e [2] ; retornar G.CHILD.test (e [0])? null: (e [3]? e [2] = e [4] || e [5] || "": n && X.test (n) && ( t = h (n,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t ), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtro: {TAG: função (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e ) {var t = m [e + ""]; retornar t || (t = novo RegExp ("(^ |" + M + ")" + e + "(" + M + "| $)")) && m (e, function (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")})}, ATTR:function (n, r, i) {return function (e) {var t = se.attr (e, n); return null == t? "! =" === r:! r || (t + = " "," = "=== r? t === i:"! = "=== r? t! == i:" ^ = "=== r? i && 0 === t.indexOf (i) : "* =" === r? i && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ =" == = r? -1 <("" + t.replace (B, "") + "") .indexOf (i): "| =" === r && (t === i || t.slice (0 , i.length + 1) === i + "-"))}}, CRIANÇA: função (h, e, t, g, v) {var y = "enésimo"! == h.slice (0,3 ), m = "último"! == h.slice (-4), x = "do tipo" === e; return 1 === g && 0 === v? function (e) {return !! e .parentNode}: function (e, t, n) {var r, i, o, a, s, u, l = y! == m? "nextSibling": "previousSibling", c = e.parentNode, f = x && e.Nome do nó.paraLowerCase (), p =! n &&! x, d =! 1; if (c) {if (y) {while (l) {a = e;while (a = a [l]) if (x? a.nodeName.toLowerCase () === f: 1 === a.nodeType) return! 1; u = l = "apenas" === h &&! u && "nextSibling"} return! 0} if (u = [m? c.firstChild: c.lastChild], m && p) {d = (s = (r = (i = (o = (a = c) [S] | | (a [S] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === k && r [1]) && r [2], a = s && c.childNodes [s]; enquanto (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if (1 === a.nodeType && + + d && a === e) {i [h] = [k, s, d]; quebrar}} else if (p && (d = s = (r = (i = (o = (a = e) [S] || (a [S] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === k && r [1]) ,! 1 === d) while (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if ((x? A.nodeNome.toLowerCase () === f: 1 === a.nodeType) && ++ d && (p && ((i = (o = a [S] || (a [S] = {})) [a.uniqueID] || (o [a .uniqueID] = {})) [h] = [k, d]), a === e)) break; return (d- = v) === g || d% g == 0 && 0 <= d / g}}}, PSEUDO:função (e, o) {var t, a = b.pseudos [e] || b.setFilters [e.toLowerCase ()] || se.error ("pseudo sem suporte:" + e); retornar a [S] ? a (o): 1 <a.length? (t = [e, e, "", o], b.setFilters.hasOwnProperty (e.toLowerCase ())? le (função (e, t) {var n , r = a (e, o), i = r.length; enquanto (i -) e [n = P (e, r [i])] =! (t [n] = r [i])} ): function (e) {return a (e, 0, t)}): a}}, pseudos: {not: le (function (e) {var r = [], i = [], s = f ( e.replace ($, "$ 1")); retornar s [S]? le (função (e, t, n, r) {var i, o = s (e, nulo, r, []), a = e.length; enquanto (a -) (i = o [a]) && (e [a] =! (t [a] = i))}): função (e, t, n) {return r [ 0] = e, s (r, nulo, n, i), r [0] = nulo,! I.pop ()}}), tem: le (função (t) {função de retorno (e) {retorno 0 <se (t, e). comprimento}}), contém: le (função (t) {retorno t = t.replace (te, ne), função (e) {retorno-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (function (n) {return V.test (n || "") || se.error ("unsupported lang:" + n),n = n.replace (te, ne) .toLowerCase (), function (e) {var t; faça {if (t = E? e.lang: e.getAttribute ("xml: lang") || e.getAttribute ("lang")) return (t = t.toLowerCase ()) === n || 0 === t.indexOf (n + "-")} enquanto ((e = e.parentNode) && 1 === e .nodeType); return! 1}}), target: function (e) {var t = n.location && n.location.hash; return t && t.slice (1) === e.id}, root: function (e) {return e === a}, focus: function (e) {return e === C.activeElement && (! C.hasFocus || C.hasFocus ()) && !! (e.type || e.href | | ~ e.tabIndex)}, ativado: ge (! 1), desativado: ge (! 0), verificado: função (e) {var t = e.nodeName.toLowerCase (); return "input" === t && !! e.checked || "option" === t && !! e.selected}, selecionado: function (e) {return e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, vazio: function (e) {para (e = e.firstChild; e; e = e.nextSibling) se (e.nodeType <6) return! 1; return! 0}, parent: function (e) {return! B.pseudos.empty (e)}, header: function (e) {return J.test (e.nodeName)}, input: function (e) {return Q.test (e.nodeName)}, botão: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && "button" === e. digite || "botão" === t}, texto: função (e) {var t; return "input" === e.nodeName.toLowerCase () && "texto" === e.type && (null == (t = e.getAttribute ("type")) || "text" === t.toLowerCase ())}, primeiro: ve (function () {return [0]}), último: ve (function (e , t) {return [t-1]}), eq: ve (função (e, t, n) {return [n <0? n + t: n]}), even: ve (função (e, t ) {para (var n = 0; n <t; n + = 2) e.push (n); retornar e}), ímpar: ve (função (e, t) {para (var n = 1; n <t ; n + = 2) e.push (n); retornar e}), lt: ve (função (e, t, n) {para (var r = n <0? n + t: t <n? t: n ; 0 <= - r;) e.push (r); retornar e}), gt: ve (função (e, t,n) {para (var r = n <0? n + t: n; ++ r <t;) e.push (r); retornar e})}}). pseudos.nth = b.pseudos.eq, {radio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) b.pseudos [e] = de (e); for (e em {enviar:! 0, redefinir :! 0}) b.pseudos [e] = he (e); function me () {} função xe (e) {for (var t = 0, n = e.length, r = ""; t <n ; t ++) r + = e [t] .value; return r} função be (s, e, t) {var u = e.dir, l = e.next, c = l || u, f = t && "parentNode "=== c, p = r ++; retornar e.first? função (e, t, n) {enquanto (e = e [u]) se (1 === e.nodeType || f) retornar s (e , t, n); retornar! 1}: função (e, t, n) {var r, i, o, a = [k, p]; se (n) {enquanto (e = e [u]) se ((1 === e.nodeType || f) && s (e, t, n)) return! 0} else while (e = e [u]) if (1 === e.nodeType || f) if (i = (o = e [S] || (e [S] = {})) [e.uniqueID] || (o [e.uniqueID] = {}), l && l === e.nodeName.toLowerCase ()) e = e [u] || e; senão {if ((r = i [c]) && r [0] === k && r [1] === p) retorna a [2] = r [2 ]; if ((i [c] = a) [2] = s (e, t, n)) retorno! 0} retorno!1}} função we (i) {return 1 <i.length? Função (e, t, n) {var r = i.length; while (r -) if (! I [r] (e, t, n)) return! 1; return! 0}: i [0]} função Te (e, t, n, r, i) {for (var o, a = [], s = 0, u = e.length , l = nulo! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s) )); retornar a} função Ce (d, h, g, v, y, e) {retornar v &&! v [S] && (v = Ce (v)), y &&! y [S] && (y = Ce (y, e)), le (função (e, t, n, r) {var i, o, a, s = [], u = [], l = t.length, c = e || função ( e, t, n) {para (var r = 0, i = t.length; r <i; r ++) se (e, t [r], n); retornar n} (h || "*", n .nodeType? [n]: n, []), f =! d ||! e && h? c: Te (c, s, d, n, r), p = g? y || (e? d: l || v)? []: t: f; if (g && g (f, p, n, r), v) {i = Te (p, u), v (i, [], n, r), o = i.length; enquanto (o -) (a = i [o]) && (p [u [o]] =! (f [u [o]] = a))} if (e) {if ( y || d) {if (y) {i = [], o = p.length; enquanto (o -) (a = p [o]) && i.push (f [o] = a); y ( nulo, p = [], i, r)} o = p.length; enquanto (o -) (a = p [o]) && -1 <(i = y? P (e, a): s [o]) && (e [i] =! (T [i] = a))}} senão p = Te (p === t ? p.splice (l, p.length): p), y? y (nulo, t, p, r): H.apply (t, p)})} função Ee (e) {for (var i, t, n, r = comprimento e.longo, o = b.relativo [e [0] .tipo], a = o || b.relativo [""], s = o? 1: 0, u = ser (função (e) {return e === i}, a,! 0), l = be (function (e) {return-1 <P (i, e)}, a,! 0), c = [function ( e, t, n) {var r =! o && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n) ); return i = null, r}]; s <r; s ++) if (t = b.relative [e [s] .type]) c = [be (we (c), t)]; else {if ((t = b.filtro [e [s] .tipo] .aplicar (nulo, e [s]. correspondências)) [S]) {para (n = ++ s; n <r; n ++) if (b .relative [e [n] .type]) break; return Ce (1 <s && we (c), 1 <s && xe (e.slice (0, s-1) .concat ({value: "" === e [ s-2] .type? "*": ""})). substituir ($, "$ 1"), t, s <n && Ee (e.slice (s, n)), n <r && Ee (e = e. fatia (n)), n <r && xe (e))} c.push (t)} return we (c)} return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) {var n, r, i , o, a, s, u, l = x [e + ""]; se (l) retornar t? 0: l.slice (0); a = e, s = [], u = b.preFiltro; enquanto (a) {para (o em n &&! (r = _. exec (a)) || (r && (a = a.slice (r [0] .comprimento) || a), s.push (i = [ ])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({valor: n, digite: r [0] .replace ($, " ")}), a = a.slice (n.length)), b.filtro)! (r = G [o] .exec (a)) || u [o] &&! (r = u [o] (r)) || (n = r.shift (), i.push ({valor: n, tipo: o, corresponde a: r}), a = a.slice (n.length)); if (! n ) break} return t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compile = function (e, t) {var n, v, y, m, xexec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push (i = [])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({valor: n, tipo: r [0] .replace ($, "")}), a = a.slice (n.length) ), b.filtro)! (r = G [o] .exec (a)) || u [o] &&! (r = u [o] (r)) || (n = r.shift (), i.push ({valor: n, tipo: o, corresponde a: r}), a = a.slice (n.length)); if (! n) quebrar} retornar t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compilar = função (e, t) {var n, v, y, m, xexec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push (i = [])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({valor: n, tipo: r [0] .replace ($, "")}), a = a.slice (n.length) ), b.filtro)! (r = G [o] .exec (a)) || u [o] &&! (r = u [o] (r)) || (n = r.shift (), i.push ({valor: n, tipo: o, corresponde a: r}), a = a.slice (n.length)); if (! n) quebrar} retornar t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compilar = função (e, t) {var n, v, y, m, x, r, i = [], o = [], a = A [e + ""]; se (! a) {t || (t = h (e)), n = t.comprimento; enquanto (n- -) (a = Ee (t [n])) [S]? i.push (a): o.push (a); (a = A (e, (v = o, m = 0 <(y = i) .comprimento, x = 0 <comprimento v., r = função (e, t, n, r, i) {var o, a, s, u = 0, l = "0", c = e && [] , f = [], p = w, d = e || x && b.find.TAG ("*", i), h = k + = nulo == p? 1: Math.random () || .1, g = d.length; for (i && (w = t == C || t || i); l! == g && null! = (o = d [l]); l ++) {if (x && o) {a = 0 , t || o.ownerDocument == C || (T (o), n =! E); enquanto (s = v [a ++]) if (s (o, t || C, n)) {r. push (o); quebrar} i && (k = h)} m && ((o =! s && o) && u -, e && c.push (o))} if (u + = l, m && l! == u) {a = 0 ; enquanto (s = y [a ++]) s (c, f, t, n); if (e) {if (0 <u) enquanto (l -) c [l] || f [l] || (f [l] = q.call (r)); f = Te (f)} H.apply (r, f), i &&! e && 0 <f.length && 1 <u + y.length && se.uniqueSort (r)} return i && (k = h, w = p), c}, m? le (r): r))). seletor = e} retornar a},g = se.selecionar = função (e, t, n, r) {var i, o, a, s, u, l = "função" == tipo de e && e, c =! r && h (e = l.seletor || e); if (n = n || [], 1 === c.length) {if (2 <(o = c [0] = c [0] .slice (0)). length && "ID" = == (a = o [0]). type && 9 === t.nodeType && E && b.relative [o [1] .type]) {if (! (t = (b.find.ID (a.matches [0]). substituir (te, ne), t) || []) [0])) retornar n; l && (t = t.parentNode), e = e.slice (o.shift (). valor.length)} i = G.needsContext.test (e)? 0: o.length; while (i -) {if (a = o [i], b.relative [s = a.type]) break; if ((u = b .find [s]) && (r = u (a.matches [0] .replace (te, ne), ee.test (o [0] .type) && ye (t.parentNode) || t))) { if (o.splice (i, 1),! (e = r.length && xe (o))) return H.apply (n, r), n; break}}} return (l || f (e, c) ) (r, t,! E, n,! t || ee.test (e) && ye (t.parentNode) || t), n}, d.sortStable = S.split (""). sort (D ) .join ("") === S, d.detectDuplicates = !! l, T (), d.sortDetached = ce (function (e) {return 1 & e.compareDocumentPosition (C.createElement ("fieldset"))}), ce (function (e) {return e.innerHTML = "<a href='#'> </ a > "," # "=== e.firstChild.getAttribute (" href ")}) || fe (" tipo | href | altura | largura ", função (e, t, n) {if (! n) retornar e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)}), d.attributes && ce (function (e) {return e.innerHTML = "<input />", e.firstChild. setAttribute ("value", ""), "" === e.firstChild.getAttribute ("value")}) || fe ("value", function (e, t, n) {if (! n && "input "=== e.nodeName.toLowerCase ()) return e.defaultValue}), ce (function (e) {return null == e.getAttribute (" disabled ")}) || fe (R, function (e, t, n) {var r; if (! n) return! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), se} (C); S.find = d, S.expr = d.selectors, S.expr [":"] = S.expr. pseudos, S.uniqueSort = S.unique = d.uniqueSort, S.text = d.getText, S.isXMLDoc = d.isXML, S.contains = d.contains, S.escapeSelector = d.escape; var h = function (e, t, n) {var r = [], i = void 0! == n; enquanto ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType ) {if (i && S (e) .is (n)) break; r.push (e)} return r}, T = function (e, t) {for (var n = []; e; e = e. nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, k = S.expr.match.needsContext; função A (e, t) {return e.nodeName && e.nodeName.toLowerCase ( ) === t.toLowerCase ()} var N = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; função D (e, n, r) {return m (n)? S.grep (e, função (e, t ) {return !! n.call (e, t, e)! == r}): n.nodeType? S.grep (e, function (e) {return e === n! == r}): "corda"!= typeof n? S.grep (e, function (e) {return-1 <i.call (n, e)! == r}): S.filter (n, e, r)} S.filter = function (e, t, n) {var r = t [0]; return n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? S.find .matchesSelector (r, e)? [r]: []: S.find.matches (e, S.grep (t, function (e) {return 1 === e.nodeType}))}, S.fn .extend ({find: function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) return this.pushStack (S (e) .filter (function ( ) {for (t = 0; t <r; t ++) if (S.contains (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0 ; t <r; t ++) S.find (e, i [t], n); retornar 1 <r? S.uniqueSort (n): n}, filtro: função (e) {return this.pushStack (D ( this, e || [] ,! 1))}, não: function (e) {return this.pushStack (D (this, e || [] ,! 0))}, is: function (e) {return !! D (this, "string" == typeof e && k.test (e)? S (e): e || [] ,! 1) .length}}); var j, q = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (S.fn.init = function (e, t, n) {var r, i; if (! e) retorna isso; if (n = n || j, "string" == typeof e) {if (! (r = "<" === e [0] && ">" === e [e.length-1] && 3 <= e.length ? [null, e, null]: q.exec (e)) ||! r [1] && t) return! t || t.jquery? (t || n) .find (e): this.constructor ( t) .find (e); if (r [1]) {if (t = t instância de S? t [0]: t, S.merge (this, S.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: E,! 0)), N.test (r [1]) && S.isPlainObject (t)) para (r in t) m (this [r])? this [r] (t [r]): this.attr (r, t [r]); retornar este} return (i = E.getElementById (r [2])) && (this [0] = i, this.length = 1), this} return e.nodeType? (this [0] = e, this.length = 1, this): m (e)? void 0! == n.ready? n.ready (e): e (S): S.makeArray (e, this)}). Prototype = S.fn, j = S (E); var L = / ^ (?: pais | anterior (?: Até | Todos)) /, H = {filhos: ! 0, conteúdo:! 0, próximo:! 0, anterior:! 0}; função O (e, t) {enquanto ((e = e [t]) &&1! == e.nodeType); return e} S.fn.extend ({has: function (e) {var t = S (e, this), n = t.length; return this.filter (function () {for (var e = 0; e <n; e ++) if (S.contains (this, t [e])) return! 0})}, mais próximo: function (e, t) {var n, r = 0 , i = this.length, o = [], a = "string"! = typeof e && S (e); if (! k.test (e)) for (; r <i; r ++) for (n = this [ r]; n && n! == t; n = n.parentNode) if (n.nodeType <11 && (a? -1 <a.index (n): 1 === n.nodeType && S.find.matchesSelector (n, e ))) {o.push (n); break} return this.pushStack (1 <o.length? S.uniqueSort (o): o)}, index: function (e) {return e? "string" == typeof e? i.call (S (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0] .parentNode? this.first () .prevAll (). length: -1}, add: function (e, t) {return this.pushStack (S.uniqueSort (S.merge (this.get (), S (e, t)))) }, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filtro (e))}}), S.each ({pai: função (e) {var t = e.parentNode; retornar t && 11! == t.nodeType? t: nulo}, pais: função (e) {retorno h (e, "parentNode")}, ParentsUntil: function (e, t, n) {return h (e, "parentNode", n)}, next: function (e) {return O (e, "nextSibling") }, prev: function (e) {return O (e, "previousSibling")}, nextAll: function (e) {return h (e, "nextSibling")}, prevAll: function (e) {return h (e, "anteriorSibling")}, nextUntil: function (e, t, n) {return h (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return h (e, "previousSibling", n)}, irmãos: função (e) {return T ((e.parentNode || {}). firstChild, e)}, children: function (e) {return T (e.firstChild)}, conteúdo: function ( e) {return null! = e.contentDocument && r (e.contentDocument)? e.contentDocument: (A (e, "modelo") && (e = e.content || e), S.merge ([], e.childNodes))}}, função (r, i) {S.fn [r] = função (e, t) {var n = S.map (this, i, e); return " Até "! == r.slice (-5) && (t = e), t &&" string "== typeof t && (n = S.filter (t, n)), 1 <this.length && (H [r] || S.uniqueSort (n), L.test (r) && n.reverse ()), this.pushStack (n)}}); var P = / [^ \ x20 \ t \ r \ n \ f] + / g; função R (e) {return e} função M (e) {jogar e} função I (e, t, n, r) {var i; try {e && m (i = e.promise)? i.call (e) .done (t) .fail (n): e && m (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r)) } catch (e) {n.apply (void 0, [e])}} S.Callbacks = function (r) {var e, n; r = "string" == typeof r? (e = r, n = {}, S.each (e.match (P) || [], função (e, t) {n [t] =! 0}), n): S.extend ({}, r); var i , t, o, a, s = [], u = [], l = -1, c = função () {para (a = a || r.uma vez, o = i =! 0; u.length; l = -1) {t = u.shift (); enquanto (++ l <s.length)! 1 === s [l] .apply (t [0], t [1]) && r.stopOnFalse && (l = s.length, t =! 1)} r.memory || (t =! 1), i =! 1, a && (s = t? []: "")}, f = {add: function () {return s && (t &&! i && (l = s.length-1, u.push (t)), função n (e) {S.each (e, function (e, t) {m (t) ? r.unique && f.has (t) || s.push (t): t && t.length && "string"! == w (t) && n (t)})} (argumentos), t &&! i && c ()), este }, remova: function () {return S.each (argumentos, função (e, t) {var n; while (-1 <(n = S.inArray (t, s, n))) s.splice (n , 1), n ​​<= l && l -}), this}, has: function (e) {return e? -1 <S.inArray (e, s): 0 <s.length}, vazio: function () {return s && (s = []), this}, desabilitar: function () {return a = u = [], s = t = "", this}, disabled: function () {return! s}, lock: function () {return a = u = [], t || i || (s = t = ""), this}, locked: function () {return !! a}, fireWith: function (e, t) {retornar a || (t = [e, (t = t || []). fatia? t.slice (): t], u.push (t), i || c ()), este}, disparar: função () {retornar f.fireCom (isto, argumentos), isto}, disparar: função () {retornar !! o}}; retornar f }, S.extend ({Adiado: função (e) {var o = [["notificar", "progresso", S.Callbacks ("memória"), S.Callbacks ("memória"), 2], [" resolver "," concluído ", S.Callbacks (" uma vez na memória "), S.Callbacks (" uma vez na memória "), 0," resolvido "], [" rejeitar "," falhar ", S.Callbacks (" uma vez na memória "), S.Callbacks (" uma vez na memória "), 1," rejeitado "]], i =" pendente ", a = {estado: função () {retorno i}, sempre: função () {retorno s.done (argumentos) .fail (argumentos), this}, "catch": function (e) {return a.then (null, e)}, pipe: function () {var i = arguments; return S.Deferred (function ( r) {S.each (o, função (e, t) {var n = m (i [t [4]]) && i [t [4]]; s [t [1]] (função () {var e = n &&n.aplicar (isto, argumentos); e && m (e.promissão)? e.promissão (). progresso (r.notificar) .done (r.resolver) .fail (r.rejeitar): r [t [0] + "Com"] (this, n? [E]: argumentos)})}), i = nulo}). Promessa ()}, então: função (t, n, r) {var u = 0; função l ( i, o, a, s) {função de retorno () {var n = this, r = argumentos, e = função () {var e, t; if (! (i <u)) {if ((e = a .apply (n, r)) === o.promise ()) throw new TypeError ("Thenable self-resolution"); t = e && ("object" == typeof e || "function" == typeof e) && e.then, m (t)? s? t.call (e, l (u, o, R, s), l (u, o, M, s)) :( u ++, t.call (e, l (u, o, R, s), l (u, o, M, s), l (u, o, R, o.notifyWith))) :( a! == R && (n = vazio 0, r = [e]), (s || o.resolveWith) (n, r))}}, t = s? e: function () {try {e ()} catch (e) {S.Deferred.exceptionHook && S.Deferred .exceptionHook (e, t.stackTrace), u <= i + 1 && (a! == M && (n = void 0, r = [e]), o.rejectWith (n, r))}}; i? t () :( S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook ()), C.setTimeout (t))}} return S.Deferred (function (e) {o [0] [3] .add (l (0, e, m (r)? r: R, e.notifyWith)), o [1] [3] .add (l (0, e, m (t)? t: R)), o [2] [3]. add (l (0, e, m (n)? n: M))}). promessa ()}, promessa: função (e) {retorno nulo! = e? S.extend (e, a): a} }, s = {}; retornar S.each (o, função (e, t) {var n = t [2], r = t [5]; a [t [1]] = n.add, r && n. add (função () {i = r}, o [3-e] [2] .desativar, o [3-e] [3] .desativar, o [0] [2] .lock, o [0] [ 3] .lock), n.add (t [3] .fire), s [t [0]] = function () {return s [t [0] + "Com"] (this === s? Void 0: este, argumentos), este}, s [t [0] + "Com"] = n.fireWith}), a.promise (s), e && e.call (s, s), s}, quando: função (e) {var n = argumentos.comprimento, t = n, r = Matriz (t), i = s.call (argumentos), o = S.Deferred (), a = função (t) {função de retorno (e ) {r [t] = isto, i [t] = 1 <argumentos.comprimento? s.call (argumentos): e, - n || o.resolveWith (r, i)}}; if (n <= 1 && (I (e, o.done (a (t)). resolve, o.reject,! n), "pendente" === o.state () || m (i [t] && i [t] .then))) return o.then (); enquanto (t -) I (i [t], a (t), o.rejeitar); retornar o.promissão ()}}); var W = / ^ (Eval | Interno | Intervalo | Referência | Sintaxe | Tipo | URI) Erro $ /; S.Deferred.exceptionHook = function (e, t) {C.console && C.console.warn && e && W.test (e.name) && C.console.warn ("exceção jQuery.Deferred:" + e.message, e.stack, t)}, S.readyException = function (e) {C.setTimeout (function () {throw e})}; var F = S.Deferred (); função B () { E.removeEventListener ("DOMContentLoaded", B), C.removeEventListener ("load", B), S.ready ()} S.fn.ready = function (e) {return F.then (e) ["catch" ] (function (e) {S.readyException (e)}), this}, S.extend ({isReady:! 1, readyWait: 1, ready: function (e) {(! 0 === e? - S.readyWait: S.isReady) || (S.isReady =! 0)! == e && 0 <- S.readyWait || F.resolveWith (E, [S])}}), S.ready.then = F.then, "complete" === E.readyState || "carregando"! == E.readyState &&! E.documentElement.doScroll? C .setTimeout (S.ready) :( E.addEventListener ("DOMContentLoaded", B), C.addEventListener ("load", B)); var $ = function (e, t, n, r, i, o, a ) {var s = 0, u = e.length, l = null == n; if ("objeto" === w (n)) for (s em i =! 0, n) $ (e, t, s, n [s] ,! 0, o, a); senão if (vazio 0! == r && (i =! 0, m (r) || (a =! 0), l && (a? (t. call (e, r), t = null) :( l = t, t = function (e, t, n) {return l.call (S (e), n)})), t)) para (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n))); retornar i? e: l? t .call (e): u? t (e [0], n): o}, _ = / ^ - ms - /, z = / - ([az]) / g; função U (e, t) { return t.toUpperCase ()} função X (e) {return e.replace (_, "ms -"). replace (z, U)} var V = function (e) {return 1 === e.nodeType | | 9 === e.nodeType ||! + E.nodeType}; função G () {this.expando = S.expando + G.uid ++} G.uid = 1, G.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = {}, V (e) && (e.nodeType? e [this. expando] = t: Object.defineProperty (e, this.expando, {valor: t, configurável:! 0}))), t}, conjunto: função (e, t, n) {var r, i = this. cache (e); if ("string" == typeof t) i [X (t)] = n; else for (r in t) i [X (r)] = t [r]; return i}, obter : function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [X (t)]}, acesso: function (e, t) , n) {return void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0 ! == n? n: t)}, remova: função (e, t) {var n, r = e [this.expando]; if (void 0! == r) {if (void 0! == t ) {n = (t = Array.isArray (t)? t.map (X) :( t = X (t)) em r? [t]: t.match (P) || []). comprimento; while (n -) excluir r [t [n]]} (vazio 0 === t || S.isEmptyObject (r)) && (e.nodeType? e [this.expando] = vazio 0: excluir e [ this.expando])}}, hasData:function (e) {var t = e [this.expando]; return void 0! == t &&! S.isEmptyObject (t)}}; var Y = new G, Q = new G, J = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, K = / [AZ] / g; função Z (e, t, n) {var r, i ; if (void 0 === n && 1 === e.nodeType) if (r = "dados -" + t.replace (K, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {try {n = "true" === (i = n) || "false"! == i && ("null" === i? null: i === + i + ""? + i: J.test (i)? JSON.parse (i): i)} catch (e) {} Q.set (e, t, n)} else n = void 0; return n} S.extend ({hasData: function (e) {return Q.hasData (e) || Y.hasData (e)}, data: function (e, t, n) {return Q.access (e, t, n )}, removeData: function (e, t) {Q.remove (e, t)}, _ data: function (e, t, n) {return Y.access (e, t, n)}, _ removeData: function ( e, t) {Y.remove (e, t)}}), S.fn.extend ({data: function (n, e) {var t, r, i, o = this [0], a = o && o .atributos; if (void 0 === n) {if (this.comprimento && (i = Q.get (o), 1 === o.nodeType &&! Y.get (o, "hasDataAttrs"))) {t = a.length; enquanto (t -) a [t] && 0 = == (r = a [t] .name) .indexOf ("data -") && (r = X (r.slice (5)), Z (o, r, i [r])); Y.set (o, "hasDataAttrs",! 0)} return i} return "object" == typeof n? this.each (function () {Q.set (this, n)}): $ (this, function (e) {var t; if (o && void 0 === e) return void 0! == (t = Q.get (o, n))? t: void 0! == (t = Z (o, n))? t: void 0; this.each (function () {Q.set (this, n, e)})}, null, e, 1 <arguments.length, null,! 0)}, removeData: function (e) {return this.each (function () {Q.remove (this, e)})}}), S.extend ({queue: function (e, t, n) {var r; if (e) return t = (t || "fx") + "fila", r = Y.get (e, t), n && (! r || Array.isArray (n)? r = Y.access (e, t, S.makeArray (n)): r.push (n)), r || []}, desenfileirar: função (e, t) {t = t || "fx"; var n = S.queue (e, t), r = n.length, i = n.shift (),o = S._queueHooks (e, t); "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), delete o.stop, i.call (e, function () {S.dequeue (e, t)}, o)) ,! r && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; retornar Y.get (e, n) || Y.access (e, n, {vazio: S.Callbacks ("uma vez na memória"). add (function () {Y.remove (e, [ t + "fila", n])})})}}), S.fn.extend ({fila: função (t, n) {var e = 2; retornar "string"! = tipo de t && (n = t, t = "fx", e -), arguments.length <e? S.queue (this [0], t): void 0 === n? this: this.each (function () {var e = S .queue (this, t, n); S._queueHooks (this, t), "fx" === t && "inprogress"! == e [0] && S.dequeue (this, t)})}, desenfileirar: function (e) {return this.each (function () {S.dequeue (this, e)})}, clearQueue:function (e) {return this.queue (e || "fx", [])}, promessa: function (e, t) {var n, r = 1, i = S.Deferred (), o = this, a = this.length, s = function () {- r || i.resolveWith (o, [o])}; "string"! = typeof e && (t = e, e = void 0), e = e || "fx"; enquanto (a -) (n = Y.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add (s)); return s () , i.promise (t)}}); var ee = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. fonte , te = new RegExp ("^ (?: ([+ -]) = |) (" + ee + ") ([az%] *) $", "i"), ne = ["Top", "Right "," Bottom "," Left "], re = E.documentElement, ie = function (e) {return S.contains (e.ownerDocument, e)}, oe = {composite:! 0}; re.getRootNode && ( ie = function (e) {return S.contains (e.ownerDocument, e) || e.getRootNode (oe) === e.ownerDocument}); var ae = function (e, t) {return "none" = == (e = t || e) .style.display || ""=== e.style.display && ie (e) && "none" === S.css (e, "display")}; função se (e, t, n, r) {var i, o, a = 20 , s = r? function () {return r.cur ()}: function () {return S.css (e, t, "")}, u = s (), l = n && n [3] || ( S.cssNumber [t]? "": "Px"), c = e.nodeType && (S.cssNumber [t] || "px"! == l && + u) && te.exec (S.css (e, t )); if (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; enquanto (a -) S.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, S .style (e, t, c + l), n = n || []} return n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1 ) * n [2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var ue = {}; function le (e, t) {para (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c <f; c ++) (r = e [c]). estilo && ( n = r.style.display, t? ("none" === n && (l [c] = Y.get (r, "display") || null, l [c] || (r.style.display = "")), "" === r.style.display && ae (r) && (l [c] = (u = a = o = void 0, a = (i = r) .ownerDocument, s = i.nodeNome, ( u = ue [s]) || (o = a.body.appendChild (a.createElement (s)), u = S.css (o, "display"), o.parentNode.removeChild (o), "nenhum "=== u && (u =" bloquear "), ue [s] = u)))):" nenhum "! == n && (l [c] =" nenhum ", Y.set (r," exibir " , n))); para (c = 0; c <f; c ++) null! = l [c] && (e [c] .style.display = l [c]); return e} S.fn.extend ({mostrar: function () {return le (this,! 0)}, ocultar: function () {return le (this)}, alternar: function (e) {return "boolean" == typeof e? e? this .show (): this.hide (): this.each (function () {ae (this)? S (this) .show (): S (this) .hide ()})}}); var ce, fe, pe = / ^ (?: caixa de seleção | rádio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, he = / ^ $ | ^ module $ | \ / (?: java | ecma) script / i; ce = E.createDocumentFragment (). appendChild (E.createElement ("div ")), (fe = E.createElement (" input ")). setAttribute (" type "," radio "), fe.setAttribute (" verificado "," verificado "), fe.setAttribute (" nome ", "t"), ce.appendChild (fe), y.checkClone = ce.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, ce.innerHTML = "<textarea> x </textarea>", y .noCloneChecked = !! ce.cloneNode (! 0) .lastChild.defaultValue, ce.innerHTML = "<option> </option>", y.option = !! ce.lastChild; var ge = {thead: [1, "<table>", "</table>"], col: [2, "<table> <colgroup>", "</colgroup> </table>"], tr: [2, "<table> < tbody> "," </tbody> </table> "], td: [3," <table> <tbody> <tr> "," </tr> </tbody> </table> "], _ padrão : [0,"", ""]}; função ve (e, t) {var n; return n = "undefined"! = typeof e.getElementsByTagName? e.getElementsByTagName (t || "*"): "undefined"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*"): [], void 0 === t || t && A (e, t)? S.merge ([e], n): n} função ye ( e, t) {para (var n = 0, r = e.length; n <r; n ++) Y.set (e [n], "globalEval",! t || Y.get (t [n], "globalEval"))} ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td, y.option || (ge.optgroup = ge.option = [1 , "<select multiple = 'multiple'>", "</select>"]); var me = / <| & #? \ w +; /; função xe (e, t, n, r, i) {para (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; d <h; d ++) if ((o = e [ d]) || 0 === o) if ("objeto" === w (o)) S.merge (p, o.nodeType? [o]: o); else if (me.test (o) ) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + S.htmlPrefilter (o) + u [2], c = u [0]; enquanto (c -) a = a.lastChild; S.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""} else p.push (t.createTextNode (o)); f.textContent = "", d = 0; while (o = p [d ++]) if (r && - 1 < S.inArray (o, r)) i && i.push (o); else if (l = ie (o), a = ve (f.appendChild (o), "script"), l && ye (a), n) { c = 0; enquanto (o = a [c ++]) he.test (o.type || "") && n.push (o)} return f} var be = / ^ chave /, we = / ^ (?: mouse | ponteiro | menu de contexto | arrastar | soltar) | clicar /, Te = / ^ ([^.] *) (?: \. (. +) |) /; função Ce () {retornar! 0} função Ee ( ) {return! 1} function Se (e, t) {return e === function () {try {return E.activeElement} catch (e) {}} () == ("focus" === t) } função ke (e, t, n, r, i, o) {var a, s; if ("objeto"== typeof t) {for (s in "string"! = typeof n && (r = r || n, n = void 0), t) ke (e, s, n, r, t [s], o) ; return e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("string" == typeof n? (i = r, r = void 0) : (i = r, r = n, n = vazio 0)) ,! 1 === i) i = Ee; senão se (! i) retornar e; retornar 1 === o && (a = i, (i = function (e) {return S (). off (e), a.apply (this, arguments)}). guid = a.guid || (a.guid = S.guid ++)), e.each (function () {S.event.add (this, t, i, r, n)})} função Ae (e, i, o) {o? (Y.set (e, i,! 1), S.event .add (e, i, {namespace:! 1, handler: function (e) {var t, n, r = Y.get (this, i); if (1 & e.isTrigger && this [i]) {if (r. comprimento) (S.event.special [i] || {}). delegateType && e.stopPropagation (); else if (r = s.call (argumentos), Y.set (this, i, r), t = o ( this, i), this [i] (), r! == (n = Y.get (this, i)) || t? Y.set (this, i,! 1): n = {}, r ! == n) return e.stopImmediatePropagation (), e.preventDefault (), n.value} else r.length && (Y.set (this, i, {value: S.event.trigger (S.extend (r [0], S.Event.prototype), r.slice (1), this)}), e.stopImmediatePropagation ())}})): void 0 === Y.get (e, i) && S.event.add (e, i, Ce)} S.event = {global: {}, adicione: função (t, e, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Y.get (t); if (V (t)) {n .handler && (n = (o = n) .handler, i = o.selector), i && S.find.matchesSelector (re, i), n.guid || (n.guid = S.guid ++), (u = v .eventos) || (u = v.events = Object.create (null)), (a = v.handle) || (a = v.handle = function (e) {return "undefined"! = typeof S && S. event.triggered! == e.type? S.event.dispatch.apply (t, argumentos): void 0}), l = (e = (e || ""). match (P) || ["" ]). comprimento; enquanto (l -) d = g = (s = Te.exec (e [l]) || []) [1], h = (s [2] || ""). dividir ("."). sort (), d && (f = S.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = S.event. especial [d] || {}, c = S.extend ({type: d, origType: g,dados: r, manipulador: n, guid: n.guid, seletor: i, needsContext: i && S.expr.match.needsContext.test (i), namespace: h.join (".")}, o), (p = u [d]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (t, r, h, a) || t .addEventListener && t.addEventListener (d, a)), f.add && (f.add.call (t, c), c.handler.guid || (c.handler.guid = n.guid)), i? p. splice (p.delegateCount ++, 0, c): p.push (c), S.event.global [d] =! 0)}}, remover: função (e, t, n, r, i) {var o , a, s, u, l, c, f, p, d, h, g, v = Y.hasData (e) && Y.get (e); if (v && (u = v.events)) {l = (t = (t || ""). match (P) || [""]). length; while (l -) if (d = g = (s = Te.exec (t [l]) | | []) [1], h = (s [2] || ""). Split ("."). Sort (), d) {f = S.event.special [d] || {}, p = u [d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join (" \\. (?:. * \\. |) ") +" (\\. | $) "), a = o = p.comprimento; enquanto (o -) c = p [o] ,! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! c.selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e , c)); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, v.handle) || S.removeEvent (e, d, v.handle), exclua u [d])} else for (d in u) S.event.remove (e, d + t [l], n, r,! 0); S.isEmptyObject (u) && Y.remove (e, "manipular eventos ")}}, despachar: função (e) {var t, n, r, i, o, a, s = novo Array (argumentos.comprimento), u = S.event.fix (e), l = (Y .get (this, "events") || Object.create (null)) [u.type] || [], c = S.event.special [u.type] || {}; for (s [0 ] = u, t = 1; t <argument.length; t ++) s [t] = argumentos [t]; if (u.delegateTarget = this,! c.preDispatch ||! 1! == c.preDispatch.call (este, u)) {a = S.event.handlers.chamar (this, u, l), t = 0; enquanto ((i = a [t ++]) &&! u.isPropagationStopped ()) {u.currentTarget = i.elem, n = 0; while ((o = i .handlers [n ++]) &&! u.isImmediatePropagationStopped ()) u.rnamespace &&! 1! == o.namespace &&! u.rnamespace.test (o.namespace) || (u.handleObj = o, u.data = o .data, void 0! == (r = ((S.event.special [o.origType] || {}). handle || o.handler) .apply (i.elem, s)) &&! 1 = == (u.result = r) && (u.preventDefault (), u.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (this, u), u.result}}, manipuladores: função (e , t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e.button)) for (; l! == this; l = l.parentNode || this) if (1 === l.nodeType && ("click"! == e.type ||! 0! == l .disabled)) {for (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). selector + ""] && (a [i] = r.needsContext? -1 <S (i, this) .index (l): S.find (i, this, null, [l]). length), a [i] && o. push (r); o.length && s.push ({elem: l, manipuladores: o})} return l = this, u <t.length && s.push ({elem: l, manipuladores: t.slice (u)}) , s}, addProp: function (t, e) {Object.defineProperty (S.Event.prototype, t, {enumerable:! 0, configurable:! 0, get: m (e)? function () {if (this .originalEvent) return e (this.originalEvent)}: function () {if (this.originalEvent) return this.originalEvent [t]}, set: function (e) {Object.defineProperty (this, t, {enumerable :! 0, configurável:! 0, gravável:! 0, valor: e})}})}, corrigir: função (e) {retornar e [S.expando]? E: novo S.Event (e)}, especial: {carregar: {noBubble:! 0}, clique em: {setup: function (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && Ae (t , "clique", Ce) ,! 1}, acionador: função (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && Ae (t, "click") ,! 0}, _ default: function (e) {var t = e.target; return pe.test (t.type) && t.click && A ( t, "input") && Y.get (t, "click") || A (t, "a")}}, beforeunload: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && ( e.originalEvent.returnValue = e.result)}}}}, S.removeEvent = função (e, t, n) {e.removeEventListener && e.removeEventListener (t, n)}, S.Event = função (e, t) {if (! (this instanceof S.Event)) return new S.Event (e, t); e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented | | void 0 === e.defaultPrevented &&! 1 === e.returnValue? Ce: Ee, this.target = e.target && 3 === e.target.nodeType? e.target.parentNode: e.target, this. currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && S.extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [S.expando] =! 0}, S.Event.prototype = {construtor: S.Event, isDefaultPrevented: Ee, isPropagationStopped: Ee, isImmediatePropagationStopped: Ee, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ce, e &&! eisprevented. ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = Ce, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEventPropagation; this.isImmediatePropagation = Ce, e &&! This.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()}}, S.each ({altKey:! 0, bubbles:! 0, cancelável:! 0, changedTouches:! 0, ctrlKey:! 0 , detalhe:! 0, eventPhase:! 0, metaKey:! 0, pageX:! 0, pageY:! 0, shiftKey :!0, visualizar:! 0, "char":! 0, código:! 0, charCode:! 0, chave:! 0, keyCode:! 0, botão:! 0, botões:! 0, clientX:! 0, clientY :! 0, offsetX:! 0, offsetY:! 0, pointerId:! 0, pointerType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que : function (e) {var t = e.button; return null == e.which && be.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! = = t && we.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, S.event.addProp), S.each ({focus: "focusin", desfoque: "focusout"}, function (e, t) {S.event.special [e] = {setup: function () {return Ae (this, e, Se) ,! 1}, trigger: function () {return Ae (this, e) ,! 0}, delegateType: t}}), S.each ({mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, function (e , i) {S.event.special [e] = {delegateType: i, bindType: i,identificador: função (e) {var t, n = e.relatedTarget, r = e.handleObj; retornar n && (n === this || S.contains (this, n)) || (e.type = r. origType, t = r.handler.apply (this, argumentos), e.type = i), t}}}), S.fn.extend ({on: function (e, t, n, r) {return ke (este, e, t, n, r)}, um: função (e, t, n, r) {retornar ke (este, e, t, n, r, 1)}, off: função (e, t , n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, S (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r. origType, r.selector, r.handler), this; if ("object" == typeof e) {for (i in e) this.off (i, t, e [i]); return this} return! 1 ! == t && "function"! = typeof t || (n = t, t = void 0) ,! 1 === n && (n = Ee), this.each (function () {S.event.remove ( this, e, n, t)})}}); var Ne = / <script | <estilo | <link / i, De = / verificado \ s * (?: [^ =] | = \ s * .checked .) / i, je = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g;function qe (e, t) {return A (e, "table") && A (11! == t.nodeType? t: t.firstChild, "tr") && S (e) .children ("tbody") [0 ] || e} função Le (e) {return e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e} função He (e) {return "true /"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}função Oe (e , t) {var n, r, i, o, a, s; if (1 === t.nodeType) {if (Y.hasData (e) && (s = Y.get (e) .eventos)) for (i in Y.remove (t, "manipular eventos"), s) for (n = 0, r = s [i] .length; n <r; n ++) S.event.add (t, i, s [i] [n]); Q.hasData (e) && (o = Q.acesso (e), a = S.extend ({}, o), Q.set (t, a))}} função Pe (n, r, i, o) {r = g (r); var e, t, a, s, u, l, c = 0, f = n.comprimento, p = f-1, d = r [ 0], h = m (d); if (h || 1 <f && "string" == typeof d &&! Y.checkClone && De.test (d)) return n.cada (função (e) {var t = n.eq (e); h && (r [0] = d.call (this, e, t.html ())), Pe (t, r, i, o) }); if (f && (t = (e = xe (r, n [0] .ownerDocument,! 1, n, o)). firstChild, 1 === e.childNodes.length && (e = t), t || o)) {for (s = (a = S.map (ve (e, "script"), Le)). length; c <f; c ++) u = e, c! == p && (u = S.clone (u,! 0,! 0), s && S.merge (a, ve (u, "script"))), i.call (n [c], u, c); if (s) for ( l = a [a.length-1] .ownerDocument, S.map (a, He), c = 0; c <s; c ++) u = a [c], he.test (u.tipo || "" ) &&! Y.access (u, "globalEval") && S.contains (l, u) && (u.src && "module"! == (u.type || ""). ToLowerCase ()? S._evalUrl &&! u.noModule && S._evalUrl (u.src, {nonce: u.nonce || u.getAttribute ("nonce")}, l): b (u.textContent.replace (je, ""), u, l)) } retorno n} função Re (e, t, n) {para (var r, i = t? S.filtro (t, e): e, o = 0; nulo! = (r = i [o]);o ++) n || 1! == r.nodeType || S.cleanData (ve (r)), r.parentNode && (n && ie (r) && ye (ve (r, "script")), r.parentNode.removeChild ( r)); return e} S.extend ({htmlPrefilter: function (e) {return e}, clone: ​​function (e, t, n) {var r, i, o, a, s, u, l, c = e.cloneNode (! 0), f = ie (e); if (! (y.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || S.isXMLDoc (e))) para ( a = ve (c), r = 0, i = (o = ve (e)). comprimento; r <i; r ++) s = o [r], u = a [r], vazio 0, "entrada" === (l = u.nodeName.toLowerCase ()) && pe.test (s.type)? u.checked = s.checked: "input"! == l && "textarea"! == l || (u. defaultValue = s.defaultValue); if (t) if (n) for (o = o || ve (e), a = a || ve (c), r = 0, i = o.length; r <i ; r ++) Oe (o [r], a [r]); senão Oe (e, c); retornar 0 <(a = ve (c, "script")). comprimento && ye (a,! f && ve (e, " script ")), c}, cleanData: function (e) {for (var t, n, r, i = S.event.special, o = 0; vazio 0!== (n = e [o]); o ++) if (V (n)) {if (t = n [Y.expando]) {if (t.eventos) para (r em t.eventos) i [r ]? S.event.remove (n, r): S.removeEvent (n, r, t.handle); n [Y.expando] = void 0} n [Q.expando] && (n [Q.expando] = void 0)}}}), S.fn.extend ({desanexar: função (e) {retornar Re (este, e,! 0)}, remover: função (e) {retornar Re (este, e)} , text: function (e) {return $ (this, function (e) {return void 0 === e? S.text (this): this.empty (). each (function () {1! == this .nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)})}, null, e, arguments.length)}, acrescente: function () {return Pe (this, arguments, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || qe (this, e) .appendChild (e)})}, prefixar: function () {return Pe ( este, argumentos, função (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = qe (this, e); t. insertBefore (e, t.firstChild)}})}, antes de:function () {return Pe (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, after: function () {return Pe (this, arguments, function (e) { this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vazio: function () {for (var e, t = 0; null! = (e = this [t]); t ++) 1 == = e.nodeType && (S.cleanData (ve (e,! 1)), e.textContent = ""); retornar isso}, clone: ​​função (e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return S.clone (this, e, t)})}, html: function (e) {return $ (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e &&! Ne.test (e) &&! Ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ()]) {e = S.htmlPrefilter (e); tente {for ( ; n <r; n ++) 1 === (t = this [n] || {}). nodeType && (S.cleanData (ve (t,! 1)),t.innerHTML = e); t = 0} catch (e) {}} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var n = [ ]; retornar Pe (isto, argumentos, função (e) {var t = this.parentNode; S.inArray (isto, n) <0 && (S.cleanData (ve (isto)), t && t.replaceChild (e, isto) )}, n)}}), S.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function (e, a ) {S.fn [e] = função (e) {para (var t, n = [], r = S (e), i = r.length-1, o = 0; o <= i; o ++) t = o === i? this: this.clone (! 0), S (r [o]) [a] (t), u.apply (n, t.get ()); return this.pushStack ( n)}}); var Me = new RegExp ("^ (" + ee + ") (?! px) [az%] + $", "i"), Ie = função (e) {var t = e. ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputedStyle (e)}, We = function (e, t, n) {var r, i, o = {}; for (i in t ) o [i] = e.style [i], e.style [i] = t [i]; for (i in r = n.call (e), t) e.style [i] = o [i]; return r}, Fe = new RegExp (ne.join ("|"), "i"); função Be (e, t, n) {var r, i, o, a, s = e.style; return (n = n || Ie (e)) && (""! == (a = n.getPropertyValue (t) || n [t]) || ie (e) || (a = S.style (e, t)) ,! y .pixelBoxStyles () && Me.test (a) && Fe.test (t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} função $ e (e, t) {return { get: function () {if (! e ()) return (this.get = t) .apply (this, arguments); delete this.get}}}! function () {function e () {if (l) {u.style.cssText = "position: absolute; left: -11111px; width: 60px; margin-top: 1px; padding: 0; border: 0", l.style.cssText = "position: relative; display: block ; box-sizing: border-box; overflow: scroll; margin: auto; border: 1px; padding: 1px; largura:60%; superior: 1% ", re.appendChild (u) .appendChild (l); var e = C.getComputedStyle (l); n =" 1% "! == e.top, s = 12 === t (e.marginLeft), l.style.right = "60%", o = 36 === t (e.right), r = 36 === t (e.width), l.style.position = "absoluto", i = 12 === t (l.offsetWidth / 3), re.removeChild (u), l = null}} função t (e) {return Math.round (parseFloat (e))} var n , r, i, o, a, s, u = E.createElement ("div"), l = E.createElement ("div"); l.style && (l.style.backgroundClip = "content-box", l .cloneNode (! 0) .style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend (y, {boxSizingReliable: function () {return e (), r}, pixelBoxStyles: function () {return e (), o}, pixelPosition: function () {return e (), n}, confiávelMarginLeft: function () {return e (), s}, scrollboxSize: function () {return e (), i}, TrustTrDimensions: function () {var e, t, n, r;return null == a && (e = E.createElement ("table"), t = E.createElement ("tr"), n = E.createElement ("div"), e.style.cssText = "position: absoluto; esquerda: -11111px ", t.style.height =" 1px ", n.style.height =" 9px ", re.appendChild (e) .appendChild (t) .appendChild (n), r = C.getComputedStyle (t ), a = 3 <parseInt (r.height), re.removeChild (e)), a}}))} (); var _e = ["Webkit", "Moz", "ms"], ze = E .createElement ("div"). style, Ue = {}; função Xe (e) {var t = S.cssProps [e] || Ue [e]; return t || (e in ze? e: Ue [ e] = função (e) {var t = e [0] .toUpperCase () + e.slice (1), n ​​= _e.length; enquanto (n -) if ((e = _e [n] + t ) in ze) return e} (e) || e)} var Ve = / ^ (none | table (?! - c [ea]). +) /, Ge = / ^ - /, Ye = {position : "absoluto", visibilidade: "oculto", exibição: "bloquear"}, Qe = {letterSpacing: "0", fontWeight: "400"};função Je (e, t, n) {var r = te.exec (t); retornar r? Math.max (0, r [2] - (n || 0)) + (r [3] || " px "): t} função Ke (e, t, n, r, i, o) {var a =" largura "=== t? 1: 0, s = 0, u = 0; if (n == = (r? "borda": "conteúdo")) retorna 0; para (; a <4; a + = 2) "margem" === n && (u + = S.css (e, n + ne [a], ! 0, i)), r? ("Conteúdo" === n && (u- = S.css (e, "preenchimento" + ne [a] ,! 0, i)), "margem"! == n && (u- = S.css (e, "borda" + ne [a] + "Largura",! 0, i))) :( u + = S.css (e, "preenchimento" + ne [a] ,! 0, i), "preenchimento"! == n? U + = S.css (e, "borda" + ne [a] + "Largura",! 0, i): s + = S.css (e, "borda "+ ne [a] +" Largura ",! 0, i)); return! r && 0 <= o && (u + = Math.max (0, Math.ceil (e [" offset "+ t [0] .toUpperCase ( ) + t.slice (1)] - ous-.5)) || 0), u} função Ze (e, t, n) {var r = Ie (e), i = (! y.boxSizingReliable () || n) &&"border-box" === S.css (e, "boxSizing",! 1, r), o = i, a = Be (e, t, r), s = "deslocamento" + t [0]. toUpperCase () + t.slice (1); if (Me.test (a)) {if (! n) return a; a = "auto"} return (! y.boxSizingReliable () && i ||! y.reliableTrDimensions () && A (e, "tr") || "auto" === a ||! ParseFloat (a) && "inline" === S.css (e, "display",! 1, r)) && e .getClientRects (). length && (i = "border-box" === S.css (e, "boxSizing",! 1, r), (o = s em e) && (a = e [s])) , (a = parseFloat (a) || 0) + Ke (e, t, n || (i? "borda": "conteúdo"), o, r, a) + "px"} função et (e, t, n, r, i) {return new et.prototype.init (e, t, n, r, i)} S.extend ({cssHooks: {opacity: {get: function (e, t) {if ( t) {var n = Be (e, "opacity"); return "" === n? "1": n}}}}, cssNumber: {animationIterationCount:! 0, columnCount:! 0,fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, gridArea:! 0, gridColumn:! 0, gridColumnEnd:! 0, gridColumnStart:! 0, gridRow:! 0, gridRowEnd:! 0, gridRowStart:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {}, style: function ( e, t, n, r) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i, o, a, s = X (t), u = Ge.test (t) , l = e.style; if (u || (t = Xe (s)), a = S.cssHooks [t] || S.cssHooks [s], void 0 === n) retorna a && "obter" em um && void 0! == (i = a.get (e,! 1, r))? i: l [t]; "string" === (o = typeof n) && (i = te.exec (n )) && i [1] && (n = se (e, t, i), o = "número"), nulo! = n && n == n && ("número"! == o || u || (n + = i && i [3] || (S.cssNumber [s]? "": "Px")), y.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || ( l [t] = "herdar "), a &&" definir "em um && void 0 === (n = a.set (e, n, r)) || (u? l.setProperty (t, n): l [t] = n)) }}, css: function (e, t, n, r) {var i, o, a, s = X (t); return Ge.test (t) || (t = Xe (s)), (a = S.cssHooks [t] || S.cssHooks [s]) && "get" in a && (i = a.get (e,! 0, n)), void 0 === i && (i = Be (e , t, r)), "normal" === i && t em Qe && (i = Qe [t]), "" === n || n? (o = parseFloat (i) ,! 0 === n | | isFinite (o)? o || 0: i): i}}), S.each (["altura", "largura"], função (e, u) {S.cssHooks [u] = {obter: function (e, t, n) {if (t) return! Ve.test (S.css (e, "display")) || e.getClientRects (). length && e.getBoundingClientRect (). width? Ze (e, u, n): We (e, Ye, function () {return Ze (e, u, n)})}, set: function (e, t, n) {var r, i = Ie (e), o =! y.scrollboxSize () && "absoluto" === i.position, a = (o || n) && "border-box" === S.css (e, "boxSizing ",! 1, i), s = n? Ke (e, u, n, a, i): 0; retornar a && o && (s- = Math.ceil (e [" offset "+ u [0] .toUpperCase () + u.slice (1)] - parseFloat (i [u]) - Ke (e, u, "fronteira",! 1, i) -. 5)), s && (r = te.exec (t) ) && "px"! == (r [3] || "px") && (e.style [u] = t, t = S.css (e, u)), Je (0, t, s) }}}), S.cssHooks.marginLeft = $ e (y.reliableMarginLeft, função (e, t) {if (t) return (parseFloat (Be (e, "marginLeft")) || e.getBoundingClientRect (). left-We (e, {marginLeft: 0}, function () {return e.getBoundingClientRect (). left})) + "px"}), S.each ({margin: "", padding: "", border : "Largura"}, função (i, o) {S.cssHooks [i + o] = {expandir: função (e) {para (var t = 0, n = {}, r = "string" == typeof e? e.split (""): [e]; t <4; t ++) n [i + ne [t] + o] = r [t] || r [t-2] || r [0] ; return n}}, "margin"! == i && (S.cssHooks [i + o].set = Je)}), S.fn.extend ({css: function (e, t) {return $ (this, function (e, t, n) {var r, i, o = {}, a = 0 ; if (Array.isArray (t)) {for (r = Ie (e), i = t.length; a <i; a ++) o [t [a]] = S.css (e, t [a] ,! 1, r); return o} return void 0! == n? S.style (e, t, n): S.css (e, t)}, e, t, 1 <arguments.length)} }), ((S.Tween = et) .protótipo = {construtor: et, init: função (e, t, n, r, i, o) {this.elem = e, this.prop = n, this. easing = i || S.easing._default, this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (S.cssNumber [n ]? "": "px")}, cur: function () {var e = et.propHooks [this.prop]; return e && e.get? e.get (this): et.propHooks._default.get (this )}, execute: function (e) {var t, n = et.propHooks [this.prop]; retornar this.options.duration? this.pos = t = S.easing [this.easing] (e, this. options.duration * e, 0,1, this.options.duration): this.pos = t = e, this.now = (this.end-this.start) * t + this.start, this.options.step && this .options.step.call (this.elem, this.now, this), n && n.set? n.set (this): et.propHooks._default.set (this), this}}). init.prototype = et. prototype, (et.propHooks = {_ default: {get: function (e) {var t; return 1! == e.elem.nodeType || null! = e.elem [e.prop] && null == e.elem .style [e.prop]? e.elem [e.prop] :( t = S.css (e.elem, e.prop, "")) && "auto"! == t? t: 0}, conjunto: função (e) {S.fx.step [e.prop]? S.fx.step [e.prop] (e): 1! == e.elem.nodeType ||! S.cssHooks [e. prop] && null == e.elem.style [Xe (e.prop)]? e.elem [e.prop] = e.now: S.style (e.elem, e.prop, e.now + e. unidade)}}}). scrollTop = et.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, S .easing = {linear: function (e) {return e}, swing: function (e) {return.5-Math.cos (e * Math.PI) / 2}, _ default: "swing"}, S.fx = et.prototype.init, S.fx.step = {}; var tt, nt, rt, it,ot = / ^ (?: toggle | show | hide) $ /, at = / queueHooks $ /; função st () {nt && (! 1 === E.hidden && C.requestAnimationFrame? C.requestAnimationFrame (st): C. setTimeout (st, S.fx.interval), S.fx.tick ())} função ut () {return C.setTimeout (function () {tt = void 0}), tt = Date.now ()} função lt (e, t) {var n, r = 0, i = {altura: e}; para (t = t? 1: 0; r <4; r + = 2-t) i ["margem" + (n = ne [r])] = i ["preenchimento" + n] = e; retornar t && (i.opacidade = i.width = e), i} função ct (e, t, n) {para (var r, i = (ft.tweeners [t] || []). concat (ft.tweeners ["*"]), o = 0, a = i.length; o <a; o ++) if (r = i [o ] .call (n, t, e)) return r} função ft (o, e, t) {var n, a, r = 0, i = ft.prefilters.length, s = S.Deferred (). sempre (function () {delete u.elem}), u = function () {if (a) return! 1; for (var e = tt || ut (), t = Math.max (0, l.startTime + l.duração-e), n = 1- (t / l.duração || 0), r = 0, i = l.tweens.length; r <i; r ++) l.tweens [r] .run (n ); retornar s.notifyWith (o, [l,n, t]), n <1 && i? t: (i || s.notifyWith (o, [l, 1,0]), s.resolveWith (o, [l]) ,! 1)}, l = s .promise ({elem: o, props: S.extend ({}, e), opts: S.extend (! 0, {specialEasing: {}, easing: S.easing._default}, t), originalProperties: e , originalOptions: t, startTime: tt || ut (), duration: t.duration, tweens: [], createTween: function (e, t) {var n = S.Tween (o, l.opts, e, t , l.opts.specialEasing [e] || l.opts.easing); retornar l.tweens.push (n), n}, parar: função (e) {var t = 0, n = e? l.tweens .length: 0; se (a) retornar isso; para (a =! 0; t <n; t ++) l.tweens [t] .run (1); retornar e? (s.notifyWith (o, [l, 1,0]), s.resolveWith (o, [l, e])): s.rejectWith (o, [l, e]), este}}), c = l.props; for (! Função (e , t) {var n, r, i, o, a; para (n em e) if (i = t [r = X (n)], o = e [n], Array.isArray (o) && ( i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, excluir e [n]), (a = S.cssHooks [r]) && "expandir" em a) para (n em o = a.expandir (o), excluir e [r], o) n em e || (e [n] = o [n], t [n] = i );else t [r] = i} (c, l.opts.specialEasing); r <i; r ++) if (n = ft.prefilters [r] .call (l, o, c, l.opts)) return m (n.stop) && (S._queueHooks (l.elem, l.opts.queue) .stop = n.stop.bind (n)), n; return S.map (c, ct, l), m ( l.opts.start) && l.opts.start.call (o, l), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts .fail) .always (l.opts.always), S.fx.timer (S.extend (u, {elem: o, anim: l, queue: l.opts.queue})), l} S.Animation = S.extend (ft, {tweeners: {"*": [function (e, t) {var n = this.createTween (e, t); return se (n.elem, e, te.exec (t) , n), n}]}, interpolador: função (e, t) {m (e)? (t = e, e = ["*"]): e = e.match (P); para (var n , r = 0, i = e.length; r <i; r ++) n = e [r], ft.tweeners [n] = ft.tweeners [n] || [], ft.tweeners [n] .unshift (t)}, pré-filtros: [função (e, t, n) {var r, i, o, a, s, u, l, c, f = "largura" em t || "altura" em t, p = this, d = {}, h = e.style, g = e.nodeType && ae (e), v = Y.get (e,"fxshow"); for (r in n.queue || (null == (a = S._queueHooks (e, "fx")). não enfileirado && (a.unqueued = 0, s = a.empty.fire, a .empty.fire = function () {a.unqueued || s ()}), a.unqueued ++, p.always (function () {p.always (function () {a.unqueued -, S.queue ( e, "fx"). comprimento || a.empty.fire ()})})), t) if (i = t [r], ot.test (i)) {if (delete t [r], o = o || "toggle" === i, i === (g? "hide": "show")) {if ("show"! == i ||! v || void 0 === v [r]) continue; g =! 0} d [r] = v && v [r] || S.style (e, r)} if ((u =! S.isEmptyObject (t)) ||! S. isEmptyObject (d)) for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y .get (e, "exibir")), "nenhum" === (c = S.css (e, "exibir")) && (l? c = l: (le ([e] ,! 0), l = e.style.display || l, c = S.css (e, "exibir"), le ([e]))), ("inline "=== c ||" inline-block "=== c && null! = l) &&" none "=== S.css (e," float ") && (u || (p.done (function ( ) {h.display = l}), null == l && (c = h.display, l = "nenhum" === c? "": c)), h.display = "inline-block")), n.overflow && (h.overflow = "oculto", p.always (function () {h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [ 2]})), u =! 1, d) u || (v? "Oculto" em v && (g = v.hidden): v = Y.access (e, "fxshow", {display: l}) , o && (v.hidden =! g), g && le ([e] ,! 0), p.done (function () {for (r in g || le ([e]), Y.remove (e, " fxshow "), d) S.style (e, r, d [r])})), u = ct (g? v [r]: 0, r, p), r em v || (v [r ] = u.start, g && (u.end = u.start, u.start = 0))}], pré-filtro: função (e, t) {t? ft.prefilters.unshift (e): ft.prefilters. push (e)}}), S. velocidade = função (e, t, n) {var r = e && "objeto" == typeof e? S.extend ({}, e): {complete: n ||! n && t || m (e) && e, duration: e, easing: n && t || t &&! m (t) && t}; return S.fx.off?r.duration=0:"number"!=typeof r.duration && (r.duration in S.fx.speeds? r.duration = S.fx.speeds [r.duration] : r.duration = S.fx.speeds._default), null! = r.queue &&! 0! == r.queue || (r.queue = "fx"), r.old = r.complete, r. complete = function () {m (r.old) && r.old.call (this), r.queue && S.dequeue (this, r.queue)}, r}, S.fn.extend ({fadeTo: function (e , t, n, r) {return this.filter (ae) .css ("opacity", 0) .show (). end (). animate ({opacity: t}, e, n, r)}, anime : função (t, e, n, r) {var i = S.isEmptyObject (t), o = S.velocidade (e, n, r), a = função () {var e = ft (this, S. extend ({}, t), o); (i || Y.get (this, "terminar")) && e.stop (! 0)}; retornar a.finish = a, i ||! 1 === o.queue? this.each (a): this.queue (o.queue, a)}, stop: function (i, e, o) {var a = function (e) {var t = e.stop; delete e.stop, t (o)}; return "string "! = typeof i && (o = e, e = i, i = void 0), e && this.queue (i ||" fx ", []), this.each (function () {var e =! 0, t = null! = i && i + "queueHooks", n = S.timers, r = Y.get (this); if (t) r [t] && r [t] .stop && a (r [t]); else for (t in r) r [t] && r [t] .parar && at.test (t) && a (r [t]); para (t = n.length; t -;) n [t] .elem! == isto || null! = i && n [t] .queue! == i || (n [t] .anim.stop (o), e =! 1, n.splice (t, 1)) ;! e && o || S.dequeue (this, i)})}, termine: function (a) {return! 1! == a && (a = a || "fx"), this.each (function () {var e, t = Y.get (this), n = t [a + "queue"], r = t [a + "queueHooks"], i = S.timers, o = n? n.length: 0; for (t.finish =! 0, S .queue (this, a, []), r && r.stop && r.stop.call (this,! 0), e = i.length; e -;) i [e].elem === this && i [e] .queue === a && (i [e] .anim.stop (! 0), i.splice (e, 1)); para (e = 0; e <o; e ++) n [e] && n [e] .finish && n [e] .finish.call (this); delete t.finish})}}), S.each (["alternar", "mostrar", "ocultar"], função (e, r) {var i = S.fn [r]; S.fn [r] = função (e, t, n) {return null == e || "booleano" == typeof e? i.apply (isto, argumentos): this.animado (lt (r,! 0), e, t, n)}}), S.each ({slideDown: lt ("mostrar"), slideUp: lt ("ocultar") , slideToggle: lt ("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (e, r) {S. fn [e] = função (e, t, n) {retornar este.animado (r, e, t, n)}}), S.timers = [], S.fx.tick = função () {var e , t = 0, n = S.timers; para (tt = Date.now (); t <n.length; t ++) (e = n [t]) () || n [t]! == e | | n.splice (t -, 1); n.length || S.fx.stop (), tt = vazio 0}, S.fx.temporizador = função (e) {S.timers.push (e), S.fx.start ()}, S.fx.interval = 13, S.fx.start = função () {nt || (nt =! 0, st ())}, S.fx.stop = function () {nt = null}, S.fx.speeds = {lento: 600, rápido: 200, _default: 400}, S.fn.delay = function (r, e) {return r = S.fx && S.fx.speeds [r] || r, e = e || "fx", this.queue (e, função (e, t) {var n = C. setTimeout (e, r); t.stop = function () {C.clearTimeout (n)}})}, rt = E.createElement ("input"), it = E.createElement ("select"). appendChild ( E.createElement ("option")), rt.type = "checkbox", y.checkOn = ""! == rt.value, y.optSelected = it.selected, (rt = E.createElement ("input") ) .value = "t", rt.type = "radio", y.radioValue = "t" === rt.value; var pt, dt = S.expr.attrHandle; S.fn.extend ({attr: function (e, t) {return $ (this, S.attr, e, t, 1 <arguments.length)}, removeAttr: function (e) {return this.each (function () {S.removeAttr (this, e)})}}), S.extend ({attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2 ! == o) return "undefined" == typeof e.getAttribute? S.prop (e, t, n) :( 1 === o && S.isXMLDoc (e) || (i = S.attrHooks [t.toLowerCase ()] || (S.expr.match.bool.test (t)? Pt: void 0)), void 0! == n? Null === n? Void S.removeAttr (e, t): i && "set" in i && void 0! == (r = i.set (e, n, t))? r: (e.setAttribute (t, n + ""), n): i && "get" in i && null! == (r = i.get (e, t))? r: null == (r = S.find.attr (e, t))? void 0: r)}, attrHooks: {type: {set: function ( e, t) {if (! y.radioValue && "radio" === t && A (e, "input")) {var n = e.value; return e.setAttribute ("type", t), n && (e. valor = n), t}}}}, removeAttr: função (e, t) {var n, r = 0, i = t && t.match (P); if (i && 1 === e.nodeType) enquanto (n = i [r ++]) e.removeAttribute (n)}}), pt = {set: function (e, t, n) {return! 1 === t? S.removeAttr (e, n): e.setAttribute (n, n), n} }, S.each (S.expr.match.bool.source.match (/ \ w + / g), função (e, t) {var a = dt [t] || S.find.attr; dt [t ] = função (e, t, n) {var r, i, o = t.toLowerCase (); retornar n || (i = dt [o], dt [o] = r, r = nulo! = a ( e, t, n)? o: nulo, dt [o] = i), r}}); var ht = / ^ (?: input | select | textarea | botão) $ / i, gt = / ^ (? : a | area) $ / i; função vt (e) {return (e.match (P) || []). join ("")} função yt (e) {return e.getAttribute && e.getAttribute ("class ") ||" "} função mt (e) {return Array.isArray (e)? e:" string "== typeof e && e.match (P) || []} S.fn.extend ({prop: function (e, t) {return $ (this, S.prop, e, t, 1 <arguments.length)}, removeProp: function (e) {return this.each (function () {delete this [S.propFix [ e] || e]})}}), S.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o &&2! == o) return 1 === o && S.isXMLDoc (e) || (t = S.propFix [t] || t, i = S.propHooks [t]), void 0! == n? I && "definir" em i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "obter" em i && null! == (r = i.get (e , t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = S.find.attr (e, "tabindex"); return t? parseInt (t, 10 ): ht.test (e.nodeName) || gt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {"for": "htmlFor", "class": "className" }}), y.optSelected || (S.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null}, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}), S.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding "," rowSpan "," colSpan "," useMap "," frameBorder "," contentEditable "], function () {S.propFix [this.toLowerCase ()] = this}), S.fn.extend ({ addClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) return this.each (function (e) {S (this) .addClass ( t.call (this, e, yt (this)))}); if ((e = mt (t)). length) while (n = this [u ++]) if (i = yt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; enquanto (o = e [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + " "); i! == (s = vt (r)) && n.setAttribute (" class ", s)} retornar isso}, removeClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) retorna this.each (function (e) {S (this) .removeClass (t.call (this, e, yt (this)))}); if (! argumentos.comprimento) retornam this.attr ("classe", ""); if ((e = mt (t)). comprimento) enquanto (n = isto [u ++]) if (i = yt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; while (o = e [a ++]) while (-1 <r.indexOf ("" + o + "")) r = r.replace (" "+ o +" "," "); i! == (s = vt (r)) && n.setAttribute (" class ", s)} retornar isso}, toggleClass: function (i, t) {var o = typeof i, a = "string" === o || Array.isArray (i); return "boolean" == typeof t && a? t? this.addClass (i): this.removeClass (i): m (i)? this.each (function (e) {S (this) .toggleClass (i.call (this, e, yt (this), t), t)}): this.each (function () {var e, t, n, r; se (a) {t = 0, n = S (este), r = mt (i); enquanto (e = r [t ++]) n.hasClass (e)? n.removeClass (e): n.addClass (e)} else void 0! == i && "boolean"! == o || ((e = yt (this)) && Y.set (this, "__ className __", e), this.setAttribute && this.setAttribute ("class", e ||! 1 === i? "": Y.get (this, "__ className__") || ""))})}, hasClass: function (e) {var t, n, r = 0; t = "" + e + ""; enquanto (n = this [r ++]) if (1 == = n.nodeType && - 1 <("" + vt (yt (n)) + "") .indexOf (t)) return! 0; return! 1}}); var xt = / \ r / g; S. fn.extend ({val: function (n) {var r, e, i, t = this [0]; retornar argumentos.length? (i = m (n), this.each (function (e) {var t ; 1 === this.nodeType && (null == (t = i? N.call (this, e, S (this) .val ()): n)? T = "": "number" == typeof t ? t + = "": Array.isArray (t) && (t = S.map (t, função (e) {return null == e? "": e + ""})), (r = S.valHooks [ this.type] || S.valHooks [this.nodeName.toLowerCase ()]) && "set" in r && void 0! == r.set (this, t, "value") || (this.value = t) )})): t? (r = S.valHooks [t.type] || S.valHooks [t.nodeName.toLowerCase ()]) && "get" in r && void 0! == (e = r.get ( t, "valor "))? e:" string "== typeof (e = t.value)? e.replace (xt," "): null == e?" ": e: void 0}}), S.extend ({valHooks: {opção: {obter: função (e) {var t = S.find.attr (e, "valor"); retornar nulo! = t? t: vt (S.text (e))}} , selecione: {get: function (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a? null: [], u = a? o + 1: i.length; for (r = o <0? u: a? o: 0; r <u; r ++) if (((n = i [r]). selecionado || r === o) &&! n.disabled && (! n.parentNode.disabled ||! A (n.parentNode, "optgroup"))) {if (t = S (n) .val (), a ) retornar t; s.push (t)} retornar s}, definir: função (e, t) {var n, r, i = e.options, o = S.makeArray (t), a = i.length; while (a -) ((r = i [a]). selected = -1 <S.inArray (S.valHooks.option.get (r), o)) && (n =! 0); return n | | (e.selectedIndex = -1), o}}}}), S.each (["radio", "checkbox"], function () {S.valHooks [this] = {set: function (e, t ) {if (Array.isArray (t)) return e.checked = -1 <S.inArray (S (e) .val (), t)}}, y.checkOn || (S.valHooks [this] .get = function (e) {return null === e.getAttribute ("value")? "on": e.value})}), y.focusin = "onfocusin" em C; var bt = / ^ (?: focusinfocus | focusoutblur) $ /,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i, o, a, s, u, l , c, f, p = [n || E], d = v.call (e, "tipo")? e.type: e, h = v.call (e, "namespace")? e.namespace. split ("."): []; if (o = f = a = n = n || E, 3! == n.nodeType && 8! == n.nodeType &&! bt.test (d + S.event.triggered ) && (- 1 <d.indexOf (".") && (d = (h = d.split (".")). Shift (), h.sort ()), u = d.indexOf (": ") <0 &&" on "+ d, (e = e [S.expando]? E: novo S.Event (d," object "== typeof e && e)). IsTrigger = r? 2: 3, e.namespace = h.join ("."), e.rnamespace = e.namespace? new RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") + "(\\. | $)") : null, e.result = void 0, e.target || (e.target = n), t = null == t? [e]: S.makeArray (t, [e]), c = S.event .special [d] || {}, r ||! c.trigger ||! 1! == c.trigger.apply (n, t))) {if (! r &&! c.noBubble &&! x (n) ) {for (s = c.delegateType || d, bt.test (s + d) || (o = o.parentNode); o; o = o.parentNode) p.push (o), a = o; a === (n.ownerDocument || E) && p.push (a.defaultView || a.parentWindow || C)} i = 0; while ((o = p [i ++]) &&! e.isPropagationStopped () ) f = o, e.type = 1 <i? s: c.bindType || d, (l = (Y.get (o, "events") || Object.create (null)) [e.type] && Y.get (o, "handle")) && l.apply (o, t), (l = u && o [u]) && l.apply && V (o) && (e.result = l.apply (o, t) ,! 1 === e.result && e.preventDefault ()); return e.type = d, r || e.isDefaultPrevented () || c._default &&!1! == c._default.apply (p.pop (), t) ||! V (n) || u && m (n [d]) &&! X (n) && ((a = n [u]) && (n [u] = null), S.event.triggered = d, e.isPropagationStopped () && f.addEventListener (d, wt), n [d] (), e.isPropagationStopped () && f.removeEventListener (d, wt), S.event.triggered = void 0, a && (n [u] = a)), e.result}}, simular: função (e, t, n) {var r = S.extend (novo S. Evento, n, {type: e, isSimulated:! 0}); S.event.trigger (r, null, t)}}), S.fn.extend ({trigger: function (e, t) {return this .each (function () {S.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; if (n) return S.event.trigger (e, t, n,! 0)}}), y.focusin || S.each ({focus: "focusin", blur: "focusout"}, função (n, r) {var i = function (e ) {S.event.simulate (r, e.target, S.event.fix (e))}; S.event.special [r] = {setup: function () {var e = this.ownerDocument || this .documento || this, t = Y.access (e, r); t || e.addEventListener (n, i,! 0), Y.access (e, r, (t || 0) +1)}, desmontar: function () {var e = this.ownerDocument || this.document || this, t = Y.access (e, r) -1; t? Y.access (e, r, t) :( e.removeEventListener (n, i,! 0), Y.remove (e, r))}} }); var Tt = C.location, Ct = {guid: Date.now ()}, Et = / \? /; S.parseXML = function (e) {var t; if (! e || "string" ! = typeof e) return null; try {t = (new C.DOMParser) .parseFromString (e, "text / xml")} catch (e) {t = void 0} return t &&! t.getElementsByTagName ("parsererror" ) .length || S.error ("XML inválido:" + e), t}; var St = / \ [\] $ /, kt = / \ r? \ n / g, At = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, Nt = / ^ (?: input | select | textarea | keygen) / i; função Dt (n, e, r, i) {var t; if (Array .isArray (e)) S.each (e, function (e, t) {r || St.test (n)? i (n, t): Dt (n + "[" + ("objeto" == typeof t && null! = t? e: "") + "]", t, r, i)}); else if (r || "objeto"!== w (e)) i (n, e); senão para (t em e) Dt (n + "[" + t + "]", e [t], r, i)} S.param = função (e , t) {var n, r = [], i = função (e, t) {var n = m (t)? t (): t; r [comprimento r] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (null == e) return ""; if (Array.isArray (e) || e.jquery &&! S.isPlainObject (e)) S.each (e, função () {i (this.name, this.value)}); else for (n in e) Dt (n, e [n], t, i); return r.join ("&") }, S.fn.extend ({serialize: function () {return S.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = S.prop ( this, "elements"); return e? S.makeArray (e): this}). filter (function () {var e = this.type; return this.name &&! S (this) .is (": disabled" ) && Nt.test (this.nodeName) &&! At.test (e) && (this.checked ||! Pe.test (e))}). Map (function (e, t) {var n = S (this ) .val ();return null == n? null: Array.isArray (n)? S.map (n, function (e) {return {name: t.name, value: e.replace (kt, "\ r \ n")} }): {name: t.name, value: n.replace (kt, "\ r \ n")}}). get ()}}); var jt = /% 20 / g, qt = / #. * $ /, Lt = / ([? &]) _ = [^ &] * /, Ht = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm , Ot = / ^ (?: GET | HEAD) $ /, Pt = / ^ \ / \ //, Rt = {}, Mt = {}, It = "* /". Concat ("*"), Wt = E.createElement ("a"); função Ft (o) {função de retorno (e, t) {"string"! = Tipo de e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase (). match (P) || []; if (m (t)) while (n = i [r ++]) "+" === n [0]? (n = n.slice (1) || "*", (o [n] = o [n] || []). Unshift (t)) :( o [n] = o [n] || []). Push (t )}} função Bt (t, i, o, a) {var s = {}, u = t === Mt; função l (e) {var r; return s [e] =! 0, S.each (t [e] || [], função (e, t) {var n = t (i, o, a); retornar "string"! = tipo de n || u || s [n]? u ?! (r = n): vazio 0: (i.dataTypes.unshift (n), l (n) ,! 1)}),r} return l (i.dataTypes [0]) ||! s ["*"] && l ("*")} função $ t (e, t) {var n, r, i = S.ajaxSettings.flatOptist (t)? S (e) .position () [n] + "px": t})}), S.each ({Height: "height", Width: "width"}, function (a, s ) {S.each ({preenchimento: "interno" + a, conteúdo: s, "": "externo" + a}, função (r, o) {S.fn [o] = função (e, t) { var n = argumentos.comprimento && (r || "booleano"! = tipo de e), i = r || (! 0 === e ||! 0 === t? "margem": "borda"); retornar $ (this, function (e, t, n) {var r; return x (e)? 0 === o.indexOf ("externo")? e ["interno" + a]: e.document.documentElement [ "client" + a]: 9 === e.nodeType? (r = e.documentElement, Math.max (e.body ["scroll" + a], r ["scroll" + a], e.body [ "deslocamento" + a], r ["deslocamento" + a], r ["cliente" + a])): vazio 0 === n? S.css (e, t, i): S.style (e , t, n, i)}, s, n? e: void 0, n)}})}), S.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess "," ajaxSend "], function (e, t) {S.fn [t] = function (e) {return this.on (t, e)}}), S.fn.extend ({bind: function (e, t, n) {retornar this.on (e, nulo, t, n)}, desvincular: função (e, t) {retornar this.off (e, nulo, t)}, delegado: função (e , t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === arguments.length? this.off (e, " ** "): this.off (t, e ||" ** ", n)}, pairar: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}) , S.each ("desfocar foco foco em foco para fora redimensionar rolar clique dblclique mouse para baixo mouseup mousemove mouseover mouseout mouseenter para deixar mudar selecionar enviar tecla pressionada tecla pressionada tecla contexto menu" .split (""), função (e, n) {S.fn [n] = function (e, t) {return 0 <arguments.length? this.on (n, null, e, t): this.trigger (n)}}); var Gt = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; S.proxy = função (e, t) {var n, r, i; if ("string "== tipo de t && (n = e [t], t = e, e = n), m (e)) return r = s.call (argumentos, 2), (i = função () {return e. aplicar (t || this, r.concat (s.call (argumentos)))}). guid = e.guid = e.guid || S.guid ++, i}, S.holdReady = function (e) {e ? S.readyWait ++: S.ready (! 0)}, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = A, S.isFunction = m, S.isWindow = x, S. camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (e) {var t = S.type (e); return ("número" === t || "string "=== t) &&! isNaN (e-parseFloat (e))}, S.trim = function (e) {return null == e?" ":( e +" "). replace (Gt," ") }, "função" == typeof define && define.amd && define ("jquery", [], function () {return S}); var Yt = C.jQuery, Qt = C. $; return S.noConflict = function (e) {return C. $ === S && (C. $ = Qt), e && C.jQuery === S && (C.jQuery = Yt), S}, "indefinido"== typeof e && (C.jQuery = C. $ = S), S});